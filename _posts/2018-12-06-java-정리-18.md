---
layout: post
title: Java 정리 18
tags: [Java]
excerpt: "Java 정리 - 자주 사용하는 클래스들(2), JCF"
date: 2018-12-06
comments: true
---

## Java 정리 18 - Calendar, DecimalFormat, Random, JCF

---

### Calendar

* **한가지 날짜정보를 얻을 땐 Calendar가 좋고 형식있는 전체를 얻을 땐 SimpleDateFormat이 좋음.**
* Calendar는 **생성된 시점의 날짜 정보**를 갖고 있다.
  * 다른날의 날짜를 얻기 위해선 **set**을 사용

```java
import java.util.Calendar;
import java.util.GregorianCalendar;
public class UseCalendar {
  public UseCalendar() {
    Calendar cal = Calendar.getInstance();
    Calendar cal1 = new GregorianCalendar();
    GregorianCalendar gc = new GregorianCalendar();
    
    int year = cal.get(Calendar.YEAR);
    // 월, java에서는 월의 시작이 0월
    int month = cal.get(Calendar.MONTH)+1;
    int day = cal.get(Calendar.DAY_OF_MONTH);
    
    // 올해 몇번째 날인지
    int dayOfYear = cal.get(Calendar.DAY_OF_YEAR);
    
    System.out.printf("%d-%d-%d 오늘은 올해의 %d번째  날\n",
              year,month,day,dayOfYear);
    // 요일 : 일(1), 월(2), 화(3), 수(4), 목(5), 금(6),  토(7)
    int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
    
    /*switch(dayOfWeek) { // case 1~7, 가독성이 낮다
    case 1:    System.out.println("일요일");   break;
    case 2:    System.out.println("월요일");   break;
    case 3:    System.out.println("화요일");   break;
    case 4:    System.out.println("수요일");   break;
    case 5:    System.out.println("목요일");   break;
    case 6:    System.out.println("금요일");   break;
    case 7:    System.out.println("토요일");   break;
    }*/
  
    /*String week="";
    // 상수 사용하여 가독성 향상
    switch(dayOfWeek) {
    case Calendar.SUNDAY:
        week="일요일";  break;
    case Calendar.MONDAY:
        week="월요일";  break;
    case Calendar.TUESDAY:
        week="화요일";  break;
    case Calendar.WEDNESDAY:
        week="수요일";  break;
    case Calendar.THURSDAY:
        week="목요일";  break;
    case Calendar.FRIDAY:
        week="금요일";  break;
    case Calendar.SATURDAY:
        week="토요일";  break;
    }
    System.out.printf("%d요일 %s\n",dayOfWeek, week);*/
    
    // 배열 활용하는 방식(권장)
    String[] weekTitle = {  "일","월","화","수","목","금","토" };
    System.out.printf("%d요일 %s요일\n",dayOfWeek,
              weekTitle[dayOfWeek-1]);
  
    // 오전(0) 오후(1)
    int amPm = cal.get(Calendar.AM_PM);
      
    // 상수 Calendar.AM, Calendar.PM을 이렇게 사용
    /*switch(amPm) {
    case Calendar.AM:
        System.out.println("오전");
        break;
    case Calendar.PM:
        System.out.println("오후");
        break;
    }*/
      
    // 배열로
    String[] arrAmPm = { "오전", "오후" };
    System.out.printf("%d %s\n",amPm, arrAmPm[amPm]);

    // 삼항연산자로
    System.out.printf("%s\n", amPm == Calendar.AM ?  "오전" : "오후");
      
    // 시간
    int hour = cal.get(Calendar.HOUR);   // 12시간제
    int hour24 = cal.get(Calendar.HOUR_OF_DAY); //  24시간제
    System.out.printf("%d(%d)시\n", hour, hour24);
      
    int minute = cal.get(Calendar.MINUTE);
    int second = cal.get(Calendar.SECOND);
    System.out.printf("%d(%d):%d:%d\n",hour,hour24,minute,second);
      
      // Calendar는 생성된 시점의 날짜 정보를 가짐
      // 다른 날짜를 얻기 위해선 set을 사용
    System.out.println("-----------------------------------------------");
    System.out.printf("설정 전 %d-%d-%d %s요일\n",
        cal1.get(Calendar.YEAR),  cal1.get(Calendar.MONTH)+1,
        cal1.get(Calendar.DAY_OF_MONTH),
        "일,월,화,수,목,금,토".split(",")[cal1.get(Calendar.DAY_OF_WEEK)-1]);
      
    // 년
    cal1.set(Calendar.YEAR, 2019);
    // 월 - 사람이 생각하는 월보다 1적게 설정
    cal1.set(Calendar.MONTH, 4);
    // 일 - 해당월의 존재하지 않는 일자가 설정되면  자동으로 다음달로 넘어가 설정됨
    cal1.set(Calendar.DAY_OF_MONTH, 32);
    
    System.out.printf("설정 후 %d-%d-%d %s요일\n",
      cal1.get(Calendar.YEAR),  cal1.get(Calendar.MONTH)+1,
      cal1.get(Calendar.DAY_OF_MONTH),
      "일,월,화,수,목,금,토".split(",")[cal1.get(Calendar.DAY_OF_WEEK)-1]);
    System.out.println("-----------------------------------------------");
      
    // 이번달의 마지막 날을 알 수 있는 getActualMaximum
    System.out.println(cal1.getActualMaximum(Calendar.DATE));
    System.out.println(cal1.getActualMaximum(Calendar.DAY_OF_MONTH));
  }
  
  public static void main(String[] args) {
    new UseCalendar();
  }
}
```

---

### DecimalFormat

* **숫자 형식을 변경**(1000(정수) -> 1,000(문자열))
* java.text 패키지에 존재
* 패턴
  * 오라클 0 - 자바 0
    * 0으로 채우기
  * 오라클 9 - 자바 #
    * 존재하는 숫자만 출력
* 오라클보다 자바 format해주는게 좋은점은 오라클은 입력값이 패턴길이를 넘어가면 출력을 못하는 반면 자바는 입력값이 넘어가도 패턴을 적용시켜줌

```java
// 1.생성
DecimalFormat df = new DecimalFormat("패턴");

// 2.사용
df.format(패턴을적용할숫자);
```

```java
public class UseDecimalFormat {
  
  public UseDecimalFormat() {
    int temp = 20181206;
    
    // 데이터가 없음 0을 채움
    DecimalFormat df = new  DecimalFormat("0,000,000,000");
    // 데이터가 없으면 채우지 않음
    DecimalFormat df1 = new  DecimalFormat("#,###,###,###");
    
    System.out.println("0사용 : "+df.format(temp)); // 0,020,181,206
    System.out.println("#사용 : "+df1.format(temp)); // 20,181,206
    
    DecimalFormat df2 = new DecimalFormat("#,###.00");
    // 실수자릿수를 사용하면 마지막 뒷자리의 값이
    // 반올림대상이라면 반올림한 결과를 보여준다.
    System.out.println("소수자리수 표현 :  "
      +df2.format(201812.066)); // 201,812.07
  }
  
  public static void main(String[] args) {
    new UseDecimalFormat();
  }
}
```

---

### Random

* java.util 패키지
* 다양한 **난수**를 뽑기 위해서 제작된 클래스
* **생성되면 모든 난수가 발생**
  * **패턴을 분석하면 다음 수 예측가능(보안에 취약)**

```java
// 1.생성
Random r = new Random();

// 2.난수얻기
r.nextDouble(); // 실수난수(0~1 사이 실수)
// 실수난수로 발생가짓수 내 정수난수를 얻을 때
(int)(r.nextDouble()*발생가짓수); 

r.nextInt(); // 정수난수 (-2147483648~+2147483647 사이 랜덤값)

// 발생가짓수 안에 랜덤한 값을 얻고자 할 때 아래와 같이하면
// 음수도 나올 수 있다. 따라서 Math.abs()를 사용
r.nextInt()%발생가짓수;
Math.random(r.nextInt()%발생가짓수);

// 오버로딩된 nextInt를 사용하면 발생가짓수-1의 
// 임의의 양의 정수가 반환된다(권장)
r.nextInt(발생가짓수);

// 랜덤 Boolean값도 가질 수 있다.
r.nextBoolean();
```

```java
public class UseRandom {
  public UseRandom() {
    // 1.생성
    Random r = new Random();
    
    // 2.난수얻기
    // 실수난수
    double d = r.nextDouble();
    System.out.println(d);
    System.out.println(d*5);
    System.out.println((int)(d*5));
    
    System.out.println("-----------------------");
    
    // 정수난수
    int i = r.nextInt(); // 음수가 발생하므로  절대값처리
    System.out.println(i);
    System.out.println(i%5);
    System.out.println(Math.abs(i%5)); // 양수처리
    
    System.out.println("-----------------------");
    int j = r.nextInt(5); // 음수가 발생하지 않는다.
    System.out.println(j);
    
    System.out.println("-----------------------");
    
    // 불린난수
    boolean b = r.nextBoolean();
    System.out.println(b);
  }
  public static void main(String[] args) {
    new UseRandom();
  }
}
```

---

### 오토박싱 & 언박싱(autoboxing & unboxing)

* **jdk 1.5 이전에는 기본형과 참조형 간 연산 불가능했었음**
  * **래퍼 클래스**로 기본형을 객체로 만들어 연산해야 했다.
* jdk 1.5부터는 **컴파일러가 자동으로 변환**하는 코드를 넣어줌.
  * **기본형 값을 래퍼 클래스의 객체롤 자동변환해주는 것을 오토박싱(autoboxing), 반대로 변환하는 것을 언박싱(unboxing)이라 함**

---

### JCF(Java Collection FrameWork)

* **데이터를 다룰 때 사용(=자료구조)**
* java.util 패키지에서 제공
* **Collection 계열, Map**
  * **Collection 계열 = List, Set**
* **가변길이형**
  * 데이터를 추가하면 크기가 늘어나고 삭제하면 크기가 줄어듦.
  * 메모리를 효율적으로 사용
* **Generic과 같이 사용**
  * Generic은 jdk 1.5에서 추가된 기능
  * jdk 1.4까지는 Object만 저장 가능했지만 jdk 1.5부터는 모든 값을 저장할 수 있다. (autoboxing, unboxing 지원)

![01](https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/18/01.png?raw=true)

* **Collection**
  * **List**
    * 1차원 배열처럼 생성, 사용
    * 가변길이형
    * **중복값 저장가능, 검색 기능이 있다**
    * **데이터가 순차적으로 입력됨**
    * **ArrayList, LinkedList, Vector** 구현 클래스 존재
  * **Set**
    * 1차원 배열처럼 생성, 사용
    * 가변길이형
    * **중복값 저장불가, 검색 기능이 없다**
      * **검색 기능이 없어 Iterator(포인터 객체)를 사용**
    * **데이터가 순차적으로 입력되지 않음**
    * **HashSet** 구현 클래스 존재
* **Map**
  * 2차원 배열처럼 생성
  * 가변길이형
  * **키와 값의 쌍(entry)으로 이루어진 데이터형**
    * 2차원 배열이지만 열은 2개
  * **키는 중복될 수 없음, 값은 중복가능**
  * **데이터(\<K,V\>, entry)가 순차적으로 입력되지 않음**
  * **Hashtable, HashMap** 구현 클래스 존재



