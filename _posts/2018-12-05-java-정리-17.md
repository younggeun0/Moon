---
layout: post
title: Java 정리 17
tags: [Java]
excerpt: "Java 정리 - 자주 사용되는 클래스들"
date: 2018-12-05
comments: true
---

## Java 정리 17 - StringBuffer, StringBuilder, StringTokenizer, Math

---

### StringBuffer, StringBuilder

* **문자열을 heap에 저장**
  * 같은 문자열을 여러개를 저장하게 됨
  * 메소드를 불러서 일을하면 원본문자열이 변경이 됨
* 둘 중 하나만 사용가능하면 다 쓸 수 있게됨 **(사용법 동일)**
* 차이점
  * **StringBuffer - 멀티쓰레드 동시접근 불가능**
  * **StringBuilder - 멀티쓰레드 동시접근가능**
    * 속도때문에 Builder 많이 사용한다.

```java
// 생성
StringBuffer sb = new StringBuffer();

// 값 덧붙임(오버로드로 많이 구현되어 있음)
// 정수, 실수, 문자, 문자열, boolean들을 문자열로 추가 가능
// 추가한 값을 저장한 문자열의 주소를 반환
sb.append(값);

// append 반환형이 StringBuffer이므로 메소드체인 가능
sb.append("Hello ").append("World!");

// 문자열로 반환할 때
String s = sb.toString();

// 값을 삽입, 0번 인덱스에 값 삽입
sb.insert(인덱스, 값);

// 문자열의 순서를 뒤집을 수 있음
sb.reverse();

// 값 삭제
sb.delete(시작인덱스, 끝인덱스+1);

// String과 동일한 기능의 메소드들이 많다
sb.indexOf("12");
sb.lastIndexOf("5");
sb.charAt(23);
sb.substring(sb.indexOf("안녕"));
```


* **String은 짧은 문자열** 다룰 때 **StringBuilder와 StringBuffer는 긴 문자열**을 다룰 때 사용
  * **짧은 문자열**은 글자수 상관없이 **"로 시작, "로 끝나는 문자열**
  * **긴 문자열은 "안"+"녕"과 같이 추가적인 연산**이 들어가는 문자열
    * **String은 '+'사용하지 않는다.(StringBuilder 사용!)**

```java
String str1 = "안";
// 문자열에 '+'가 붙어서 긴 문자열이 된다.
System.out.println(str1+"녕"+"하"+"세"+"요"+".");
// new  StringBuilder().append(str1).append("녕").append("하")...;

// decompiler로 바이트코드를 보면 자바는 긴문자열을 StringBuilder로 처리
```

![01](https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/17/01.png?raw=true)

---

### StringTokenizer

* java.util 패키지에서 제공
* 문자열을 짧은 한 마디(token)로 구분할 때 사용
* **StringTokenizer는 포인터**
  * 단어 하나하나를 토큰으로 분리
  * **nextToken()**메소드를 호출하여 값을 얻고 다음 토큰으로 포인터 이동
  * **포인터는 뒤로 갈 수 없다.**
* String의 split과는 다르게 StringTokenizer는 구분자로 **'.'로도 자를 수 있다.**

```java
// 공백으로 토큰을 구분한다
String s = "";
StringTokenizer stk = new StringTokenizer(s);

// 토큰의 개수를 알아내는 countTokens()
stk.countTokens();

// 토큰이 존재하면 true, 없으면 false를 리턴하는 hasMoreTokens()
stk.hasMoreTokens();

// 값(String)을 얻고 다음 토큰으로 포인터를 이동하는 nextToken()
stk.nextToken();

// 문자열을 구분자 나눌 땐 인수2개짜리 생성자 호출
String = str = "오늘은, 수요일, 입니다.";
StringTokenizer strStk = new StringTokenizer(str, ",");

// 구분자도 토큰으로 사용할 땐 인수3개짜리 생성자 호출, true면 보호
StringTokenizer strStk2 = new StringTokenizer(str, ",", true);
```

```java
import java.util.StringTokenizer;
public class STKTest {
  public static void main(String[] args) {
    
    String s = "";
    s = "오늘은 수요일 입니다.";
    StringTokenizer stk = new StringTokenizer(s);
    
    System.out.println(stk.countTokens()); // 3
    
    while(stk.hasMoreTokens()) {
      System.out.println(stk.nextToken());
    }

    String str = "오늘은, 수요일, 입니다.";
    StringTokenizer stk1 = new StringTokenizer(str, ",");
    
    while(stk1.hasMoreTokens()) {
      System.out.println(stk1.nextToken());
    }
    
    StringTokenizer stk2 = new StringTokenizer(str, ",", true);

    while(stk2.hasMoreTokens()) {
      System.out.println(stk2.nextToken());
    }

    String names =  "이재현,이재찬~정택성,김희철.김정운~김정윤,공선의";
    // ',~.'로 구분
    StringTokenizer stk4 = new  StringTokenizer(names, ",~.");
    System.out.println("토큰의 수 :  "+stk4.countTokens());
    while(stk4.hasMoreTokens()) {
      System.out.println(stk4.nextToken());
    }
  }
}
```

### Math

* java.lang 패키지에 있는 클래스
* **수학적인 일을 할 때 사용하는 클래스**
* API Doc을 보면 생성자가 없음
  * **생성자에 private이 붙은 것**
  * **객체화해서 사용하는 클래스가 아님**
* **method만 호출하여 사용하는 클래스**

```java
// 절대값
Math.abs(-10); // 10

// 반올림, 자바는 소수점이하 첫 번째자리에서 반올림(오라클 처럼 자리수 지정 못함)
Math.round(10.4); // 10
Math.round(10.5); // 11

// 올림, 0은 올리지 않는다. 
Math.ceil(10.1); // 11

// 절삭, 소수 이하를 절삭하는 메소드는 없다. => 그냥 casting
(int)10.1

// 내림, 소수점 이하 첫번째자리에서 내림
Math.floor(10.6); // 10

// 난수, 0~1사이 임의의 실수(double, 소수점이하 16자리)을 반환
Math.random();
// 0~9 사이 난수를 얻기 위해선 
Math.random()*10;
```

```java
// A-Z 중 하나의 문자를 반환하는 일.알파벳은 26개. 65-90(대문자),  97-122(소문자)
// 랜덤 대문자 출력
for(int j=0; j<5; j++) {
  System.out.println((char)((int)(Math.random()*26)+65));
}
// 랜덤 소문자 출력
for(int j=0; j<5; j++) {
  System.out.println((char)((int)(Math.random()*26)+97));
}
```

```java
// 난수 메소드를 이용해서 임의의 비밀번호 구하기
// 계정 비번찾기시 새비번을 반환해주는 메소드
// 48~57 숫자 65~90 대문자, 97~122 소문자
// 영문자대문자,소문자,숫자로 이루어진
// 임의의 비밀번호 8자리를 생성하여 반환하는 일
public class UseMath {
  public char[] createPassword() {
    char[] tempPass = new char[8];
    
    int rNum=0;
    for(int i=0; i<tempPass.length; i++) {
      while(true) {
        rNum = (int)(Math.random()*122)+1;
        if ((rNum > 47 && rNum < 58) || (rNum  > 64 && rNum <91)
                || (rNum > 96 && rNum <  123)) {
          break;
        }
      }
      System.out.println((char)rNum);
      tempPass[i] = (char)rNum;
    }
    System.out.println(tempPass);
    return tempPass;
  }

  // 다른 짧은 방식
  public char[] createPassword2() {
    char[] tempPass = new char[8];
    String flag=
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    for(int i=0; i<tempPass.length; i++) {
      tempPass[i] = flag.charAt((int)(Math.random()*flag.length()));
    }
    
    System.out.println(tempPass);
    return tempPass;
  }
  
  public static void main(String[] args) {
      
    new UseMath().createPassword();
    new UseMath().createPassword2();
  }

  // switch문 사용한 방식(if보다 좋은 방식)
  public char[] createPassword3() {
    char[] tempPass = new char[8];
    
    int flag = 0;
    
    for(int i=0; i<tempPass.length; i++) {
      flag = (int)(Math.random()*3)+1;
      
      switch(flag) {
      case 1: // 숫자
        tempPass[i] =  (char)((int)(Math.random()*10)+48);
        break;
      case 2: // 대문자
        tempPass[i] =  (char)((int)(Math.random()*26)+65);
        break;
      case 3: // 소문자
        tempPass[i] =  (char)((int)(Math.random()*26)+97);
        break;
      }
    }

    System.out.println(tempPass);
    return tempPass;
  }
}
```

---

