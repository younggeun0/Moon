---
layout: post
title: Java 정리 02
tags: [Java]
excerpt: "Java 정리 - 기본문법(데이터형, 연산자)"
date: 2018-11-14
comments: true
---

## Java 정리 02 - 데이터형, 연산자

---

### 데이터형 (Data Type)

* 값을 저장하기 위해 미리 예약해놓은 공간들
* **변수**를 선언할 때 사용
* **기본형 데이터형, 참조형 데이터형 2가지**
    * **기본현 데이터형 (Primitive Data Type)**
        * 변수에 값 자체를 저장하는 데이터형
    * **참조형 데이터형 (Reference Data Type)**
        * 변수에 객체의 주소를 저장하는 데이터형


### 기본형 데이터형 (Primitive Data Type)

* 변수에 값이 저장되는 데이터형
    * **Signed** - 수의 범위가 음수, 양수를 가짐
    * **Unsigned** - 수의 범위가 양수만 가짐 **(char, boolean)**
* **정수는 주로 int 사용**
* **실수는 주로 double 사용**
* **아스키코드 영소문자 시작 코드값은 알아야함**
    * **'A' - 65**
    * **'a' - 97**
    * **'0' - 48**
    * 좌측 alt + 우측 키패드로 코드값입력하면 아스키코드 문자입력됨

* **Literal**
    * long에 30억을 할당할 때 30억이란 값은 **정수 상수**
        * 할당안되고 에러발생
        * 리터럴 크기를 변경하는 형명시를 하면 할당 됨
    * 상수가 메모리에 저장될 때 그 저장 공간을 **literal** 이라고 함
    * **리터럴은 정해진 크기가 있다.**
        * **정수 - 4byte**
        * **실수 - 8byte**
    * 리터럴의 크기를 변경하고 싶을 때 **형명시**를 사용

```java
// 30억의 정수 리터럴은 4byte
// => 30억 정수상수를 담기위해선 8byte 리터럴이 필요
// 정수상수 뒤에 l, L을 붙임
long l = 3000000000l; 

// 0.5란 실수 리터럴은 8byte
// => float은 4byte이므로 8byte를 4byte로 줄여야 함
// 실수상수 뒤에 f, F를 붙임
float f = 0.5f;
```

![01](https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/02/01.PNG?raw=true)


```java
/*
	기본형 데이터형(Primitive DataType)
	정수형 : byte, short, int, long
	실수형 : float, double
	문자형 : char
	논리형 : boolean
*/
class PrimitiveDataType {
	
	public static void main(String[] args) {
		// 정수형
		byte b = 10;
		short s = 20;
		int i = 30;
		// 할당되는 값이 4byte내 이므로 literal을 변환할 필요가 없다.
		long l = 40;
		
		b = -128; // byte : -128 ~ +127
		
		// 정수 literal은 4byte
		// 저장하려는 값은 8byte가 필요한 값이므로 
		// literal의 크기를 변경(형명시), 정수상수 뒤에 l이나 L을 붙인다
		long l2 = 2147483648L;
		
		System.out.println("byte : " + b + ", short : " + s + ", int : " + i 
			+ ", long : " + l + ", long2 : " + l2);

		/*
		  0  - 정수상수
		 '0' - 문자상수
		 "0" - 문자열상수
		*/

		// 문자형 : unicode 값 : \u0000
		// 할당은 unicode가 됨
		// char c = 'A';
		// char c2 = '0';
		// char c3 = '가';

		// 유니코드값을 바로 할당해도 같은 결과 출력
		char c = 65;
		char c2 = 48;
		char c3 = 44032;

		// 출력은 unicode에 대한 문자가 출력됨
		System.out.println("char : " + c +", " + c2 + ", " + c3);

		// 실수형 
		// float형은 4byte, 3.14란 실수 리터럴은 8byte
		// float형에 8byte 실수 리터럴을 담기위해
		// f 또는 F를 실수리터럴 뒤에 붙여 형명시
		float f = 3.14F;

		// double은 literal과 datatype의 크기가 같으므로
		// 형명시를 생략할 수 있다. (d, D)
		double d = 3.14;
		double d2 = 3.14D;

		System.out.println("float : " + f + ", double : "
			+ d + ", double2 : " + d2);

		// 불린형 
		boolean tu = true;
		boolean fa = false;

		// tu = 0; boolean은 true, false만 담을 수 있다. 
		// c처럼 1, 0을 사용하지 않는다.

		System.out.println("boolean : " + tu + ", boolean : " + fa);
	}// main 
}// class
```

---

### 자동형변환

```java
byte b = 10; // byte 타입은 1byte를 넣을 수 있고 정수 literal은 4byte.
// 할당 안돼야 정상인데??

short s = 10; // short 타입은 2byte 얘한테도 할당안돼야 하는데??

// but, 자동형변환 때문에 가능
```

```java
byte b1 = 10, b2 = 20, result = 0;

// error! - 자동형변환 때문에 에러발생
result = b1 + b2;

// byte와 byte 연산되고선 결과가 int로 발생
```

* int의 하위 데이터형 (byte, short, char)이 연산되면 결과가 int로 발생되는 것
* int의 하위 데이터형에 값이 할당되면 값이 하위 데이터형의 크기에 맞게 변환되는 것


