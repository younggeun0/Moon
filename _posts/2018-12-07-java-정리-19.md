---
layout: post
title: Java 정리 19
tags: [Java]
excerpt: "Java 정리 - JFC"
date: 2018-12-07
comments: true
---
 
## Java 정리 19 - Set, Map

---

### Set

* **중복값을 저장하지 않는다.**
    * 값을 유일하게 관리
* **값이 순차적으로 추가되지 않는다.**
* 값의 검색이 되지 않는다.(get메소드가 없다)
    * **Iterator**를 사용
* 구현된 HashSet 사용

```java
// 1.생성) jdk 1.5이전에서는 Generic 사용불가, 객체만 넣는다
Set set = new HashSet();      // jdk 1.5이전 
Set<E> set = new HashSet<>(); // jdk 1.5+

// 2. 값 할당) 값이 객체면 그냥 입력, 기본형 데이터형인 경우 autoboxing 된다.
// autoboxing - wrapper class를 사용하여 객체가 만들어지고 입력되는 것
set.add(값);

// 3. 방의 개수) 
set.size();

// 4. 방의 값 삭제) set은 순차적으로 입력되지 않으므로 index로 삭제불가, 값으로만 삭제
set.remove(값);

// 5. 조회할 수 없다!(검색 안됨), Iterator를 사용, 제어권을 넘겨준다
Iterator<E> ita = set.iterator(); // set의 제어권(포인터)을 받아옴

while(ita.hasNext()) {
    System.out.println(ita.next());
}
```

```java
// Set을 사용해서 로또 중복번호 제거하기
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

public class LottoUsingSet {

    public int[] lotto() {
        int[] tempLotto = new int[6];
        
        Random random = new Random();
        for(int i=0; i<tempLotto.length; i++) {
            // 같은 수가 발생가능
            tempLotto[i] = random.nextInt(45)+1;
            for(int j=0; j<i; j++) {
                if(tempLotto[i] == tempLotto[j]) {
                    // 중복발생된 번호의 인덱스 번호를
                    // 다시 발생시키기 위해 인덱스 번호를 하나 줄인다.
                    i--;
                    break;
                }
            }
        }
        return tempLotto;
    }
    
    public Integer[] lottoUsingSet() {
        Integer[] tempLotto = new Integer[6];
        
        Set<Integer> set = new HashSet<Integer>();
        
        Random random = new Random();
        while(true) {
            // 같은수가 추가되지 않음
            set.add(random.nextInt(45)+1);
            
            if(set.size() == 6) break;
        }
        
        set.toArray(tempLotto);
        return tempLotto;
    }
    
    public static void main(String[] args) {
        
        LottoUsingSet lus = new LottoUsingSet();
        
        int[] temp = lus.lotto();
    
        for(int i=0; i<temp.length; i++) {
            System.out.print(temp[i]+" ");
        }
        
        System.out.println("\n------------------");
        
        Integer[] temp1 = lus.lottoUsingSet();
        for(int i=0; i<temp1.length; i++) {
            System.out.print(temp1[i]+" ");
        }
    }
}
```

---

### Map

* **키와 값의 쌍(KVP, Key Value Pair, entry)**으로 이루어진 데이터형
    * 2차원 배열처럼 생성(행, 열)
    * 열은 2개(K,V)만 존재
* 가변길이형
* **키는 중복될 수 없다.**
    * 식별가능해야 하기 때문에 유일해야 함
    * 값은 중복값을 가질 수 있다.
* 키를 사용하여 값을 얻는다.
* 구현된 Hashtable, HashMap
    * 생성자 오버로드로 행의 수를 넣을 수 있다.
    * **전체행의 약 75%의 데이터가 존재할 때 가장 빠른 검색을 수행**
    * **Hashtable**은 멀티쓰레드에서 동시접근이 안된다.(동기화 O, 16개의 행 생성)
    * **HashtMap**은 멀티쓰레드에서 동시접근이 가능.(동기화 X, 11개의 행 생성)

```java
// 1.생성)
Map<K,V> map = new HashMap<K,V>();
             = new Hashtable<K,V>();

// 2.값추가) - autoboxing
map.put(키, 값);

// 3.행의 개수)
map.size();

// 4.값얻기) - unboxing
map.get(키);

// 5.삭제)
map.remove(키);

// 6.모든 키 얻기) map 검증
map.keySet();

// 7.키가 존재하는지 확인)
map.containsKey(키);
```

---











