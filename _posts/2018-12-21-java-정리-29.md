---
layout: post
title: Java 정리 29
tags: [Java]
excerpt: "Java 정리 - IO Stream(3), Network"
date: 2018-12-21
feature: https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/JavaImageFeature.png?raw=true
comments: true
---
 
## Java 정리 29 - IO Stream(3), Network

---

### 파일복사

![01](https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/29/01.png?raw=true)

```java
// 복사될 파일 경로명을 설정하는 예제
public class Test {
     public static void main(String[] args) {
           
           String s =  "C:/Users/owner/youngRepositories/SSangYoung/dev/temp/java_read.txt";
           StringBuilder sb = new StringBuilder(s);
           
           // 파일명에 '.'이 여러개 나올 수 있으므로 파일 확장자는 마지막 .뒤에 문자열이다.
           // 따라서 lastIndexOf를 사용해서 확장자를 잘라내야  함.
           // StringBuilder에 삽입하는 insert method로 .있는 부분부터 "_bak"을 추가함
          System.out.println(sb.insert(s.lastIndexOf("."),"_bak"));
     }
}
```


* **FileInputStream, FileOutputStream**으로 파일 복사 구현
     * hdd에서 데이터를 읽을때 access arm이 움직여 헤드로 데이터를 읽음
     * **read 메서드**는 헤드가 얼마나 많이 읽을 수 있는지와는 상관없이 **1byte씩 읽어온다.**
          * 오버로드된 read 메서드를 보면 파라미터로 byte배열을 주면 한번에 배열의 크기만큼 읽어들일 수 있음

![02](https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/29/02.png?raw=true)

```java
byte[] b = new byte[512];
int len = 0;

// 읽어들일 때 byte배열의 크기만큼 데이터가 없을 수 있다.
len = fis.read(b); // int로 읽어들인 byte의 수를 반환
```

![03](https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/29/03.png?raw=true)

```java
// byte배열의 크기만큼 데이터가 존재하지 않을 수 있기 때문에 읽어들인 길이만큼만 출력
while(len = fis.read(b) != -1) {

    fos.write(b, 0, len); // 0번부터 len까지 출력
}
```

```java
// 파일복사 예제
@SuppressWarnings("serial")
public class FileCopy extends JFrame implements ActionListener {
     private JButton jb;
     private JProgressBar jpb;
     
     public FileCopy() {
           super("파일 복사");
           
           jb = new JButton("파일 선택");
           jpb = new JProgressBar(0, 100);
           jpb.setString("진척도");
           jpb.setStringPainted(true);
           jpb.setValue(50);
           
           JPanel jp = new JPanel();
           jp.add(jb);
           
           add("Center",jp);
           add("South",jpb);
           
           jb.addActionListener(this);
           
           setBounds(100, 100, 500, 200);
           setVisible(true);
           setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
     }
     
     @Override
     public void actionPerformed(ActionEvent e) {
           FileDialog fd = new FileDialog(this, "선택",  FileDialog.LOAD);
           fd.setVisible(true);
           
           String path = fd.getDirectory();
           String name = fd.getFile();
           
           if (path != null) { // 파일 선택시
                File file = new File(path+name);
                
                try {
                     copy(file);
                     JOptionPane.showMessageDialog(this, file+"  복사 성공.");
                } catch (FileNotFoundException fnfe) {
                     JOptionPane.showMessageDialog(this,  "파일이 존재하지 않습니다.");
                     fnfe.printStackTrace();
                } catch (IOException ie) {
                     JOptionPane.showMessageDialog(this,  "입출력 작업에 문제가 발생.");
                     ie.printStackTrace();
                }
           }
     }
     
     public void copy(File file) throws FileNotFoundException,  IOException {
           int selectValue = JOptionPane.showConfirmDialog(this,  "파일을 복사하시겠습니까?");

           switch(selectValue) {
           case JOptionPane.OK_OPTION :
                StringBuilder copyFileName = new  StringBuilder(file.getAbsolutePath());
                copyFileName.insert(copyFileName.lastIndexOf("."),  "_bak");
                
                FileInputStream fis = null;
                FileOutputStream fos = null;
                
                try {
                     // 원본 파일에 스트림 연결
                     fis = new FileInputStream(file);
                     fos = new  FileOutputStream(copyFileName.toString());
                     
                     // 파일과 연결된 스트림에서 값을 얻는다.
                     // HDD가 읽어들이는 크기를 무시하고  1byte씩 읽어들여 사용
                     int temp = 0;
                     long fileLen = file.length();
                     int i = 0;
                     while( (temp = fis.read()) != -1 ) {
                           // 읽어 들인 내용을 _bak가 붙은 파일을 생성하여 출력(복사)
                           fos.write(temp);
                           fos.flush();
                          jpb.setValue((int)(i/(double)fileLen*100));
                            // Thread를 사용해야 프로그레스바 구현가능, 여기선 값만 찍음
                           System.out.println(jpb.getValue());
                           i++;
                     }
                     
                     /*// HDD가 읽어들이는 크기를 그대로 사용
                     byte[] temp = new byte[512];
                     int len = 0;
                     while ((len = fis.read(temp)) != -1) {
                           
                           fos.write(temp,0,len);
                           fos.flush();
                     }*/
                     
                } finally {
                     if (fis != null) fis.close();
                     if (fos != null) fos.close();
                }
           }
     }
     public static void main(String[] args) {
           new FileCopy();
     }
}

```

---

### ObjectStream 

* **객체(instance)는 Stream을 타고 JVM 밖으로 나갈 수 없다.**
     * 객체의 주소는 4byte이기는 하나 객체 자체의 **크기를 알 수 없기 때문**에 쪼갤 수 없다.
* **기본형 데이터형은 Stream을 타고 JVM 밖으로 나갈 수 있다.**
     * **크기를 알 수 있기 때문**에 쪼개져서 나갈 수 있다.
* **8bit Stream**
     * **ObjectInputStream**
          * JVM 외부 객체를 읽기
     * **ObjectOutputStream**
          * JVM 외부에 객체를 내보내기
* 객체가 **직렬화(Serialization)**되면 JVM 외부로 나갈 수 있다.
     * 객체는 **Serializable이란 인터페이스를 구현**하면 직렬화 될 수 있다.
     * 직렬화된 객체는 **instanceof**를 사용해서 판별

![04](https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/29/04.png?raw=true)

```java
FileOutputStream fos = new FileOutputStream(파일객체);
ObjectOutputStream oos = new ObjectOutputStream(fos);


oos.writeObject(직렬화가된객체); // 스트림에 객체를 기록
oos.flush(); // 목적지로 분출
```


* **객체를 byte단위의 일정크기로 자름는 것이 Marshalling**
     * byte를 직렬화(일렬로) stream에 내보냄, Stream을 타고 데이터는 나뉜 byte로 출력되어 저장됨
* 직렬화를 방지하려면 변수앞에 접근지정자로 **transient**를 붙이면 그 변수는 JVM 외부로 나갈 수 없게된다.

```java
transient String s; // 
```

![05](https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/java/29/05.png?raw=true)

* **파일을 읽어와 객체로 다시 만들어 사용하는 것이 Unmarshaling**

```java
FileInputStream fis = new FileInputStream("파일명");
ObjectInputStream ois = new ObjectInputStream(fis);

B b = (B)ois.readObject();
```

